* Usage
** Building for Zynq
   To bootstrap the sw stack for a zynq board you first need to build everything with

   #+BEGIN_EXAMPLE
   make board-ready
   #+END_EXAMPLE

   This one pulls linux and uboot and other stuff and builds a ramdisk
   etc so make some coffee, it is going to take a while.

   *Note:* You will need root at some point to set uid to 0 for some
   files in the ramdisk.

** Load linux on device
   To load everything you built on your board, connect your board to
   your computer (make sure you have =xmd= though) and use the
   =load-linux.sh= script.

   For example:
   #+BEGIN_EXAMPLE
   ./load-linux.sh
   #+END_EXAMPLE
   To just load everything through =xmd= and then fire up a serial
   connection via minicom.

   Use =--help= for other options.

** Remote build
   In the special case that you are working on a mounted filesystem
   and the absolute paths of your machine match the absolute paths in
   an ssh accessible faster machine you can use the =REMOTE_SERVER=
   variable. For example:

   #+BEGIN_EXAMPLE
   make board-ready REMOTE_SERVER=192.168.1.27
   #+END_EXAMPLE

   or even

   #+BEGIN_EXAMPLE
   make board-ready REMOTE_SERVER=me@fastserver
   #+END_EXAMPLE

** Threads
   To compile directfb with 4 threads do.
   #+BEGIN_EXAMPLE
   make MAKETHREADS=4 dfb-all
   #+END_EXAMPLE

   This converts all calls to =make= into =make -j4=.

** Cleanup
   For archives you can run for exaple:
   #+BEGIN_EXAMPLE
   make libpng-clean-archive
   #+END_EXAMPLE

   To remove all traces of libpng (except from the filesystem)

** DirectFB
   To build everything run

   #+BEGIN_EXAMPLE
   make dfb-all
   #+END_EXAMPLE

** Nfsroot
   For now we do not have proper nfsroot but there is a script you can
   run to get root at your fs.

   #+BEGIN_EXAMPLE
   /homes/zynqfs/init.sh
   #+END_EXAMPLE

   That will run the init scripts as expected.

** Debug
   You may run =debug.sh <program-in-bin>= to debug something running
   on the board's gdbserver.

   From the board look for =dbi.sh <program to debug>= if you cant
   bother to look into gdb server.

** Lazy
   The problem when a makefile compiles a couple of other projects is
   that =./configure= will always run and may take quite some time
   when phony targets are being run. So each target
   =target-name-build= has an enquivalent =target-name-lazy= which
   will run =target-name-build= if there is not token file in =lazy/=
   and then create such a file. This way we can avoid configuring
   things like =libjpeg= again and again.

   For example:

   #+BEGIN_EXAMPLE
   make linux-lazy
   #+END_EXAMPLE

   will run =make linux-build= and then it will create a file. If we
   try to run again =make linux-lazy= it will just skip it.

   #+BEGIN_EXAMPLE
   make linux-clean-lazy
   #+END_EXAMPLE

   cleans the created files by lazy

   #+BEGIN_EXAMPLE
   make all-clean-lazy
   #+END_EXAMPLE

   clears all laziness.

   If you are sure you have run =linux-build= or for any reason you
   want to prevent a lazy from actually doing anything you can run.

   #+BEGIN_EXAMPLE
   make linux-shallow-lazy
   #+END_EXAMPLE

   to create the lazy file without building (again)

** Hardware
*** SD Card usage
    To use the sd card loaded stuff the switches must be:

    |    1 |    2 |  3 |  4 |    5 |
    |------+------+----+----+------|
    | Down | Down | Up | Up | Down |

*** JTAG usage
    To load linux from the jtag you must have all switches down

    |    1 |    2 |    3 |    4 |    5 |
    |------+------+------+------+------|
    | Down | Down | Down | Down | Down |

    For ZC702 you also need to setup SW10

    | JTAG Mode             | Switch 0 | Switch 1 |
    |-----------------------+----------+----------|
    | Invalid               | off      | off      |
    | Digilent USB JTAG     | off      | on       |
    | Xilinx Platform Cable | on       | off      |
    | 20-pin Header         | off      | off      |

* Notes
  MODULEDIR is absolute for host.
